#!/usr/bin/env python
# ------------------------------------------------------------
# trinity
#
# Program for lexical analysis of programs in setlan language.
#
# Author:
# Victor De Ponte, 05-38087, <rdbvictor19@gmail.com>
#
# Usage:
#
#     $ ./setlan program.stl
#
# where program.stl is a file containing the program to be
# analyzed.
# ------------------------------------------------------------
import sys

from lang import lexical_specs, syntax_specs
from lang.exceptions import (
    SetlanInputNotDefinedException,
    SetlanTokensNotDefinedException,
    SetlanLexicalErrors,
    SetlanValueError,
    SetlanSyntaxError
    )

from lib.LexerWrapper import Lexer

from ply import yacc

class SetlanInterpreter(object):
    SUCCESS = 0
    ERR_BAD_USAGE = 1
    ERR_BAD_FILENAME = 2
    ERR_IO_ERROR = 3
    ERR_LEXICOGRAPHICAL_ERROR = 4
    ERR_VALUE_ERROR = 5
    ERR_INPUT_NOT_PROVIDED = 6
    ERR_LANG_LEX_MODULE_NOT_PROVIDED = 7
    ERR_SYNTAX_ERROR = 8
    #ERR_SCOPE_ERROR = 6
    #ERR_TYPE_ERROR = 7
    #ERR_ZERO_DIVISION = 8

    USAGE = ' Usage:\n\n\t$ ./setlan program.stl\n\n where "program.stl" is a file containing the program to be analyzed.'

    def processArgs(self, args):
        if len(args) == 2:
            filename = args[1]
        else:
            print USAGE
            exit(ERR_BAD_USAGE)
        try :
            file = open(filename, 'r')
        except IOError as e:
            print "setlan: IOError: %s" % str(e)
            exit(ERR_BAD_FILENAME)
        try:
            self._inputString = file.read()
        except IOError as e:
            print "setlan: IOError: %s" % str(e)
            exit(ERR_IO_ERROR)
        self._build()
        return True

    def _build(self):
        self._lexer = None
        self._parser = None
        self._ast = None

    def run(self, print_lex=False, print_ast=True):
        self._lexer = Lexer(module=lexical_specs, inputString=self._inputString)
        if print_lex:
            for token in iter(self._lexer.token, None):
                print token
        else:
            self._parser = yacc.yacc(module=syntax_specs)
            self._ast = self._parser.parse(lexer=self._lexer)
            if print_ast :
                print self._ast

if __name__ == '__main__':
    setlan = SetlanInterpreter()
    if (setlan.processArgs(sys.argv)):
        try:
            setlan.run()
            exit(SetlanInterpreter.SUCCESS)
        except SetlanInputNotDefinedException as einp:
            print einp
            exit(SetlanInterpreter.ERR_INPUT_NOT_PROVIDED)
        except SetlanTokensNotDefinedException as etnd:
            print etnd
            exit(SetlanInterpreter.ERR_LANG_LEX_MODULE_NOT_PROVIDED)
        except SetlanLexicalErrors as esle:
            print esle
            exit(SetlanInterpreter.ERR_LEXICOGRAPHICAL_ERROR)
        except SetlanValueError as esve:
            print esve
            exit(SetlanInterpreter.ERR_VALUE_ERROR)
        except SetlanSyntaxError as esse:
            print esse
            exit(SetlanInterpreter.ERR_SYNTAX_ERROR)